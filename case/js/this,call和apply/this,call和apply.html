<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // 该方法的作用和 apply() 方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，
        // 而apply()方法接受的是一个包含多个参数的数组。



        //call(thisarg,arg1,arg2)
        //thisarg表示的是函数运行时指定的this
        //返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined
        // function a() {
        //     console.log(this);   //输出函数a中的this对象
        // }
        // function b() { }
        // var c = { name: "call" };    //定义对象c  
        // a.call();   //window

        // a.call(null);   //window

        // a.call(undefined);   //window

        // a.call(1);   //Number

        // a.call('');   //String

        // a.call(true);   //Boolean

        // a.call(b);   //function b(){}

        // a.call(c);   //Object


        // //调用一个对象的方法，以另一个对象代替该对象
        // function class1() {
        //     this.name = function () {
        //         console.log("我是class1内的方法");
        //     }
        // }
        // function class2() {
        //     class1.call(this); //此行代码执行后，当前的this指向了class1（也可以说class2继承了class1）   
        // }
        // var f = new class2();
        // f.name();   //调用的是class1内的方法，将class1的name方法交给class2使用



        // apply(thisarg,[arg1,arg2])
        // 应用某一对象的方法，用另一个对象替换当前对象
        // function a(arg1, arg2) {
        //     this.name = function () {
        //         console.log(arg1, arg2)
        //     }
        // }
        // function b() {
        //     var x = 1, y = 2;
        //     a.apply(this, [x, y])
        // }
        // var c = new b();
        // c.name()

        // 某个函数的参数数量是不固定的，因此要说适用条件的话，
        // 当你的参数是明确知道数量时用 call ；
        // 而不确定的时候用 apply，然后把参数 push 进数组传递进去。
        // 当参数数量不确定时，函数内部也可以通过  arguments这个数组来遍历所有的参数


        //bind 是ES5中拓展的方法
        //返回值是函数
        // bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，
        // 绑定函数会以创建它时传入 bind()方法的第一个参数作为 this
        // 传入bind() 方法的第二个以及以后的参数加上绑定函数运行时本身
        // 的参数按照顺序作为原函数的参数来调用原函数。
        var bar = function () {
            console.log(this)
            console.log(this.x);
        }
        var foo = {
            x: 3
        }
        bar();
        bar.bind(foo)();
        
        /*或*/
        var func = bar.bind(foo);
        func();

    </script>
</body>

</html>